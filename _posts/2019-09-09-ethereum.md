---
layout:     post
title:      How does Ethereum work, anyway
subtitle:   Ehtereum Yellow Paper
date:       2019-09-10
author:     lanbery
header-img: img/Beginners-Guide-to-Ethereum.jpg
catalog: true
tags:
  - Blockchain
  - Ethereum
    
---

> 区块链的本质:就是一个公共数据库，保存着数字交易的永久记录。
> 重要的是，这个数据库不需要任何中央机构来维护和保护它

> 它作为一个不可信的交易系统运行，在这个框架中，个人可以进行点对点交易，而不需要信任第三方或彼此

## 何为区块链?

> 区块链是一个具有共享状态的加密安全事务单例机器

  - Cryptographically secure: 加密安全意味着数字货币的创造是由复杂的难以破解的数学算法保证的。
  - Transactional singleton machine : 有一个机器的规范实例负责在系统中创建的所有事务
  - With shared-state :意味着存储在此机器上的状态是共享的，并向所有人开放

##  以太坊的一些典型特征

> The Ethereum blockchain is essentially a transaction-based state machine. In computer science, a state machine refers to something that will read a series of inputs and, based on those inputs, will transition to a new state.



<img src="/docs/images/2021/eth/eth-states-01.png" />

With Ethereum’s state machine, we begin with a “genesis state.” This is analogous to a blank slate, before any transactions have happened on the network. When transactions are executed, this genesis state transitions into some final state. At any point in time, this final state represents the current state of Ethereum.


<img src="/docs/images/2021/eth/eth-states-02.png" />
The state of Ethereum has millions of transactions. These transactions are grouped into “blocks.” A block contains a series of transactions, and each block is chained together with its previous block.

<img src="/docs/images/2021/eth/eth-states-03.png" />
To cause a transition from one state to the next, a transaction must be valid. For a transaction to be considered valid, it must go through a validation process known as mining. Mining is when a group of nodes (i.e. computers) expend their compute resources to create a block of valid transactions.


Any node on the network that declares itself as a miner can attempt to create and validate a block. Lots of miners from around the world try to create and validate blocks at the same time. Each miner provides a mathematical “proof” when submitting a block to the blockchain, and this proof acts as a guarantee: if the proof exists, the block must be valid.
For a block to be added to the main blockchain, the miner must prove it faster than any other competitor miner. The process of validating each block by having a miner provide a mathematical proof is known as a “proof of work.”

A miner who validates a new block is rewarded with a certain amount of value for doing this work. What is that value? The Ethereum blockchain uses an intrinsic digital token called “Ether.” Every time a miner proves a block, new Ether tokens are generated and awarded.

## 分叉解决机制 GHOST protocol

> “GHOST” = “Greedy Heaviest Observed Subtree”

<img src="/docs/images/2021/eth/eth-states-04.png" />


<img src="/docs/images/2021/eth/eth-states-05.png" />

Now that you’ve gotten the 10,000-foot overview of what a blockchain is, let’s dive deeper into the main components that the Ethereum system is comprised of:

  - accounts
  - state
  - gas and fees
  - transactions
  - blocks
  - transaction execution
  - mining
  - proof of work

### 账号(Accounts)

> The global “shared-state” of Ethereum is comprised of many small objects (“accounts”) that are able to interact with one another through a message-passing framework. Each account has a state associated with it and a 20-byte address. An address in Ethereum is a 160-bit identifier that is used to identify any account.

  * Externally owned accounts, which are controlled by private keys and have no code associated with them
  * Contract accounts, which are controlled by their contract code and have code associated with them.

  <img src="/docs/images/2021/eth/eth-states-06.png" />

> **Account VS Contract Account**

>> It’s important to understand a fundamental difference between externally owned accounts and contract accounts. An externally owned account can send messages to other externally owned accounts OR to other contract accounts by creating and signing a transaction using its private key. A message between two externally owned accounts is simply a value transfer. But a message from an externally owned account to a contract account activates the contract account’s code, allowing it to perform various actions (e.g. transfer tokens, write to internal storage, mint new tokens, perform some calculation, create new contracts, etc.).

>> Unlike externally owned accounts, contract accounts can’t initiate new transactions on their own. Instead, contract accounts can only fire transactions in response to other transactions they have received (from an externally owned account or from another contract account). We’ll learn more about contract-to-contract calls in the “Transactions and Messages” section.

  <img src="/docs/images/2021/eth/eth-states-07.png" />

### Account State

<img src="/docs/images/2021/eth/eth-states-08.png" />

  - nonce : 当账号为wallet账号时,表示该账号发送交易数量,当账号为合约地址时表示创建合约时的nonce数
  - balance : 余额
  - storageRoot : Merkle树根节点数据的hash
  - codeHash : The hash of the EVM (Ethereum Virtual Machine — more on this later) code of this account. For contract accounts, this is the code that gets hashed and stored as the codeHash. For externally owned accounts, the codeHash field is the hash of the empty string

<img src="/docs/images/2021/eth/eth-states-09.png" />

### World state

> 以太坊维护一个全局状态,这个状态有账户和账户状态的映射构成.这些数据存储在称之为Merkle Tree的数据结构中

  - a large number of leaf nodes at the bottom of the tree that contain the underlying data
  - a set of intermediate nodes, where each node is the hash of its two child nodes
  - a single root node, also formed from the hash of its two child node, representing the top of the tree

<img src="/docs/images/2021/eth/eth-states-10.png" />

he data at the bottom of the tree is generated by splitting the data that we want to store into chunks, then splitting the chunks into buckets, and then taking the hash of each bucket and repeating the same process until the total number of hashes remaining becomes only one: the root hash.

This tree is required to have a key for every value stored inside it. Beginning from the root node of the tree, the key should tell you which child node to follow to get to the corresponding value, which is stored in the leaf nodes. In Ethereum’s case, the key/value mapping for the state tree is between addresses and their associated accounts, including the balance, nonce, codeHash, and storageRoot for each account (where the storageRoot is itself a tree).

<img src="/docs/images/2021/eth/eth-states-11.png" />

This same trie structure is used also to store transactions and receipts. More specifically, every block has a “header” which stores the hash of the root node of three different Merkle trie structures, including:

  * State trie
  * Transactions trie
  * Receipts trie

<img src="/docs/images/2021/eth/eth-states-12.png" />

The ability to store all this information efficiently in Merkle tries is incredibly useful in Ethereum for what we call “light clients” or “light nodes.” Remember that a blockchain is maintained by a bunch of nodes. Broadly speaking, there are two types of nodes: full nodes and light nodes.

A full archive node synchronizes the blockchain by downloading the full chain, from the genesis block to the current head block, executing all of the transactions contained within. Typically, miners store the full archive node, because they are required to do so for the mining process. It is also possible to download a full node without executing every transaction. Regardless, any full node contains the entire chain.

But unless a node needs to execute every transaction or easily query historical data, there’s really no need to store the entire chain. This is where the concept of a light node comes in. Instead of downloading and storing the full chain and executing all of the transactions, light nodes download only the chain of headers, from the genesis block to the current head, without executing any transactions or retrieving any associated state. Because light nodes have access to block headers, which contain hashes of three tries, they can still easily generate and receive verifiable answers about transactions, events, balances, etc.

The reason this works is because hashes in the Merkle tree propagate upward — if a malicious user attempts to swap a fake transaction into the bottom of a Merkle tree, this change will cause a change in the hash of the node above, which will change the hash of the node above that, and so on, until it eventually changes the root of the tree.

<img src="/docs/images/2021/eth/eth-states-13.png" />

Any node that wants to verify a piece of data can use something called a “Merkle proof” to do so. A Merkle proof consists of:
A chunk of data to be verified and its hash
The root hash of the tree
The “branch” (all of the partner hashes going up along the path from the chunk to the root)

### Gas and payment



https://preethikasireddy.medium.com/how-does-ethereum-work-anyway-22d1df506369